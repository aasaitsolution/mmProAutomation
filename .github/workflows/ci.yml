name: Selenium Tests with Working Allure Trends

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Install Chrome and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y google-chrome-stable jq

      - name: Get Allure history
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          path: gh-pages
        continue-on-error: true

      - name: Setup results with existing history
        run: |
          mkdir -p target/allure-results
          if [ -d "gh-pages/history" ]; then
            echo "Copying existing history..."
            cp -r gh-pages/history target/allure-results/
          fi

      - name: Run tests
        run: mvn clean test -Dmaven.test.failure.ignore=true

      - name: Install Allure
        run: |
          wget -q https://github.com/allure-framework/allure2/releases/download/2.25.0/allure-2.25.0.tgz
          tar -zxf allure-2.25.0.tgz
          sudo mv allure-2.25.0 /opt/allure
          sudo ln -s /opt/allure/bin/allure /usr/bin/allure

      - name: Generate Allure report
        run: |
          allure generate target/allure-results -o target/allure-report --clean

      - name: Create Properly Formatted History Files
        run: |
          echo "=== Creating properly formatted history files ==="
          
          BUILD_ORDER=${{ github.run_number }}
          REPORT_NAME="Build #${BUILD_ORDER}"
          REPORT_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          # Ensure history directory exists
          mkdir -p target/allure-report/history
          cd target/allure-report/history
          
          # Count test results from the generated report
          PASSED=0
          FAILED=0
          BROKEN=0
          SKIPPED=0
          DURATION=0
          
          # Read from the generated widgets/summary.json if it exists
          if [ -f "../widgets/summary.json" ]; then
            PASSED=$(jq -r '.statistic.passed // 0' ../widgets/summary.json)
            FAILED=$(jq -r '.statistic.failed // 0' ../widgets/summary.json)
            BROKEN=$(jq -r '.statistic.broken // 0' ../widgets/summary.json)
            SKIPPED=$(jq -r '.statistic.skipped // 0' ../widgets/summary.json)
            DURATION=$(jq -r '.time.duration // 0' ../widgets/summary.json)
          else
            # Fallback: extract from existing broken format
            if [ -f "history-trend.json" ]; then
              PASSED=$(jq -r '.[0].data.passed // 0' history-trend.json)
              FAILED=$(jq -r '.[0].data.failed // 0' history-trend.json) 
              BROKEN=$(jq -r '.[0].data.broken // 0' history-trend.json)
              SKIPPED=$(jq -r '.[0].data.skipped // 0' history-trend.json)
            fi
            if [ -f "duration-trend.json" ]; then
              DURATION=$(jq -r '.[0].data.duration // 0' duration-trend.json)
            fi
          fi
          
          TOTAL=$((PASSED + FAILED + BROKEN + SKIPPED))
          DURATION_SEC=$((DURATION / 1000))
          
          echo "Test Results: P=$PASSED, F=$FAILED, B=$BROKEN, S=$SKIPPED, T=$TOTAL, D=${DURATION_SEC}s"
          
          # Create new properly formatted entries
          NEW_HISTORY=$(jq -n \
            --argjson buildOrder "$BUILD_ORDER" \
            --arg reportName "$REPORT_NAME" \
            --arg reportUrl "$REPORT_URL" \
            --argjson passed "$PASSED" \
            --argjson failed "$FAILED" \
            --argjson broken "$BROKEN" \
            --argjson skipped "$SKIPPED" \
            --argjson total "$TOTAL" \
            '{
              "buildOrder": $buildOrder,
              "reportName": $reportName,
              "reportUrl": $reportUrl,
              "data": {
                "passed": $passed,
                "failed": $failed, 
                "broken": $broken,
                "skipped": $skipped,
                "unknown": 0,
                "total": $total
              }
            }')
          
          NEW_DURATION=$(jq -n \
            --argjson buildOrder "$BUILD_ORDER" \
            --arg reportName "$REPORT_NAME" \
            --arg reportUrl "$REPORT_URL" \
            --argjson duration "$DURATION" \
            '{
              "buildOrder": $buildOrder,
              "reportName": $reportName,
              "reportUrl": $reportUrl,
              "data": {"duration": $duration}
            }')
          
          NEW_CATEGORIES=$(jq -n \
            --argjson buildOrder "$BUILD_ORDER" \
            --arg reportName "$REPORT_NAME" \
            --arg reportUrl "$REPORT_URL" \
            --argjson failed "$FAILED" \
            --argjson broken "$BROKEN" \
            '{
              "buildOrder": $buildOrder,
              "reportName": $reportName,
              "reportUrl": $reportUrl,
              "data": {
                "Product defects": $failed,
                "Test defects": $broken
              }
            }')
          
          NEW_RETRY=$(jq -n \
            --argjson buildOrder "$BUILD_ORDER" \
            --arg reportName "$REPORT_NAME" \
            --arg reportUrl "$REPORT_URL" \
            --argjson total "$TOTAL" \
            '{
              "buildOrder": $buildOrder,
              "reportName": $reportName, 
              "reportUrl": $reportUrl,
              "data": {
                "run": $total,
                "retry": 0
              }
            }')
          
          # Load existing history (properly formatted entries only)
          EXISTING_HISTORY='[]'
          EXISTING_DURATION='[]'
          EXISTING_CATEGORIES='[]'
          EXISTING_RETRY='[]'
          
          if [ -f "history-trend.json" ]; then
            # Filter out entries without buildOrder (improperly formatted)
            EXISTING_HISTORY=$(jq '[.[] | select(has("buildOrder"))]' history-trend.json 2>/dev/null || echo '[]')
          fi
          
          if [ -f "duration-trend.json" ]; then
            EXISTING_DURATION=$(jq '[.[] | select(has("buildOrder"))]' duration-trend.json 2>/dev/null || echo '[]')
          fi
          
          if [ -f "categories-trend.json" ]; then
            EXISTING_CATEGORIES=$(jq '[.[] | select(has("buildOrder"))]' categories-trend.json 2>/dev/null || echo '[]')
          fi
          
          if [ -f "retry-trend.json" ]; then
            EXISTING_RETRY=$(jq '[.[] | select(has("buildOrder"))]' retry-trend.json 2>/dev/null || echo '[]')
          fi
          
          # Create new history files (keep last 10 entries)
          echo "$EXISTING_HISTORY" | jq --argjson new "$NEW_HISTORY" '. + [$new] | if length > 10 then .[-10:] else . end' > history-trend.json
          echo "$EXISTING_DURATION" | jq --argjson new "$NEW_DURATION" '. + [$new] | if length > 10 then .[-10:] else . end' > duration-trend.json  
          echo "$EXISTING_CATEGORIES" | jq --argjson new "$NEW_CATEGORIES" '. + [$new] | if length > 10 then .[-10:] else . end' > categories-trend.json
          echo "$EXISTING_RETRY" | jq --argjson new "$NEW_RETRY" '. + [$new] | if length > 10 then .[-10:] else . end' > retry-trend.json
          
          echo "=== Final History Files ==="
          echo "history-trend.json:"
          cat history-trend.json | jq '.'
          echo ""
          echo "duration-trend.json:" 
          cat duration-trend.json | jq '.'

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        if: always()
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: target/allure-report
          keep_files: true

      - name: Deploy to SLT Server
        if: always()
        uses: burnett01/rsync-deployments@6.0.0
        with:
          switches: -avzr --delete
          path: target/allure-report/
          remote_path: /var/www/html/selenium-report
          remote_host: ${{ secrets.SLT_HOST }}
          remote_user: ${{ secrets.SLT_USER }}
          remote_key: ${{ secrets.SSH_PRIVATE_KEY }}
